### Socket 알아보기



**GOAL**

- **소켓의 정의 및 개념을 이해합니다.**
- **소켓을 사용하는 이유를 이해합니다.**
- **자바에서의 소켓 동작 원리를 이해합니다.**
- **소켓과 HTTP 통신의 차이를 이해합니다.**



#### Socket의 정의

**네트워크 소켓**(network socket)은 컴퓨터 네트워크를 경유하는 [프로세스 간 통신](https://ko.wikipedia.org/wiki/프로세스_간_통신)의 종착점이다. 오늘날 컴퓨터 간 통신의 대부분은 인터넷 프로토콜을 기반으로 하고 있으므로, 대부분의 네트워크 소켓은 **인터넷 소켓**이다. 네트워크 통신을 위한 프로그램들은 소켓을 생성하고, 이 소켓을 통해서 서로 데이터를 교환한다.

소켓 프로그래밍(Socket programming)은 네트워크의 두 노드를 연결하여 서로 통신하는 방식이다. 한 소켓(노드)은 IP의 특정 포트에서 수신되는 반면, 다른 소켓은 다른 소켓으로 손을 뻗어 연결을 형성한다. 클라이언트가 서버에 연결하는 동안 서버는 수신기 소켓을 형성한다.

 

**소켓의 구성요소는?**

- 인터넷 프로토콜(TCP, UDP, raw IP)
- 로컬 IP 주소
- 로컬 포트
- 원격 IP 주소
- 원격 포트

위와 같이 5개로 구성되어 있으며 UDP 프로토콜과, TCP 프로토콜을 사용하는 두개의 타입으로 분류할 수 있습니다.



#### Socket의 통신 방식

일반적인 서버는 특정 포트가 바인딩된 소켓을 가지고 컴퓨터 위에서 동작합니다. 해당 서버는 클라이언트의 연결 요청을 소켓을 통해 리스닝하는 상태로 대기하고 있는 상태가 되는 겁니다.

클라이언트가 서버가 동작하고 있는 호스트 네임과 서버가 리스닝하고 있는 포트 번호를 알고 있다면, 클라이언트는 이 정보를 통해 서버로 연결을 시도할 수 있습니다. 또한, 클라이언트는 서버를 상대로 자신을 식별시켜주기 위해 연결동안 사용될 로컬 포트에 바인딩해야 합니다. 이 포트 바인딩 작업은 보통 시스템에 의해서 이루어지게 됩니다.



![	](/Users/gitaejeon/Library/Application Support/typora-user-images/스크린샷 2021-04-12 오후 4.59.14.png)

정상적으로 클라이언트의 요청이 서버에게 전달되면 연결을 수락하게 됩니다. 그 이후, 서버는 동일한 로컬 포트에 바인딩 된 새로운 소켓을 얻게 되며 클라이언트 주소와 포트로 세팅된 리모트 엔드 포인트를 얻게 됩니다. 이렇게 서버가 새로운 소켓을 통해 연결을 하는 이유가 존재합니다. 연결된 클라이언트의 요청을 처리함과 동시에 기존의 소켓을 통해서는 지속적인 연결 요청을 받기 위해서입니다.



![스크린샷 2021-04-12 오후 5.02.08](/Users/gitaejeon/Library/Application Support/typora-user-images/스크린샷 2021-04-12 오후 5.02.08.png)

클라이언트는 연결이 수립되었다면, 새롭게 생성된 소켓을 통해 서버와 통신할 수 있게 됩니다. 이제 클라이언트와 서버는 소켓에 데이터를 쓰거나 읽으면서 통신할 수 있습니다.



#### 소켓 API의 실행 흐름

서로 통신하기 위해 소켓을 사용하며, 클라이언트와 서버는 각각 소켓을 생성하여 가지고 있습니다. 그리고 클라이언트와 서버가 가진 소켓은 다른 소켓이 아닌 같은 개념의 소켓입니다.(전혀 다른 소켓이 아닙니다. 생성 시기와 호출되는 함수가 다를 뿐입니다.)



소켓의 실행 흐름을 클라이언트와 서버로 분류하여 정리해보겠습니다.



**클라이언트 소켓의 실행 흐름**

1. 클라이언트가 새로운 소켓을 생성합니다. 
2. 서버로 연결을 요청합니다. 
3. 서버와 연결이 되면 데이터를 송수신합니다. 
4. 데이터의 송수신이 종료되면 소켓을 닫습니다.



**서버 소켓의 실행 흐름**

1. 서버가 새로운 소켓을 생성합니다.
2. 서버가 사용할 호스트 네임(IP 주소)와 포트 번호를 생성한 소켓에 바인딩 시킵니다.
3. 클라이언트로의 연결 요청을 리스닝합니다.
4. 요청이 수신되면, 요청을 받아 데이터 통신을 위한 새로운 소켓을 생성합니다.
5. 새로운 소켓을 통해 연결이 정상적으로 완료되었다면, 데이터를 송수신 합니다.
6. 데이터의 송수신이 종료되면 소켓을 닫습니다.



![스크린샷 2021-04-12 오후 11.25.16](/Users/gitaejeon/Library/Application Support/typora-user-images/스크린샷 2021-04-12 오후 11.25.16.png)



#### **클라이언트 소켓 API**

**소켓 생성( socket() )**

소켓으로 통신하기 위해 가장 먼저 해야 할 것은 연결할 소켓을 생성하는 일입니다. 소켓을 생성할 때, 어떠한 프로토콜을 사용할지 선택할 수 있습니다.(TCP, UPD 등) 

**연결요청( connect() )**

connect() API는 IP 주소, 포트 번호로 식별되는 대상으로 연결 요청을 보내게 됩니다. 이 때, connect() api는 블럭(block) 방식으로 동작되므로 연결 요청에 대한 결과(성공, 거절, 시간초과)를 리턴받기 전에는 실행이 끝나지 않습니다.

**데이터 송수신( send() / recv() )**

데이터를 보낼 때는 send(), 받을 때는 recv() api를 사용합니다. 또한, 이 두가지 api 모두 블럭 방식으로 동작된다는 점이 특징입니다. 위와 같이 api 실행에 대한 결과를 리턴받기 전에 실행이 끝나지 않습니다. send()의 경우 자신이 데이터를 보내기 때문에 어느정도 예상이 가능하지만, recv()의 경우 데이터가 언제 수신 될지 모릅니다.

그러므로 무한정 대기해야 하는 상황이 발생할 수도 있으므로 recv() api는 별도의 스레드를 생성해서 실행해야 합니다. 즉, 소켓의 생성이 완료되면 새로운 스레드를 생성하여 그 곳에서 recv()를 실행하고 데이터가 수신되길 기다려야 합니다.

**소켓 종료 ( close() )**

데이터의 송수신이 끝났다면 close()를 통해 소켓을 종료합니다. 종료한 소켓을 통해서는 더 이상 데이터 송수신을 할 수 없습니다.



**서버 소켓 API**

**소켓 생성( socket() )**

클라이언트 소켓과 동일하게 소켓을 생성하는 역할을 합니다.

**소켓 바인딩( bind() )**

bind() API는 소켓 바인딩을 수행합니다. API의 인자는 소켓과 포트 번호로 소켓과 포트 번호를 결합하는 역할을 합니다. 만약 다른 프로세스의 소켓과 동일한 포트번호를 바인딩하려고 할 경우에는 에러 값을 리턴하게 됩니다.

**요청 대기 ( listen() )**

소켓 바인딩이 되었다면, 소켓은 클라이언트로부터의 요청을 받아들일 준비가 되어있습니다. 그러므로 listen() api를 통해 클라이언트의 요청이 들어올 때까지 대기하는 역할을 합니다.

listen()은 클라이언트의 요청이 수신되거나 에러가 발생하면 종료됩니다. 그리고 연결이 성공되었다고 하더라도 클라이언트 요청에 대한 정보는 가지고 있지 않습니다. 연결 요청 정보는 시스템에서 내부적으로 관리하는 큐(Queue)에 쌓이며, 이 시점은 클라이언트와의 연결이 아직 완전하게 연결되지 않은 대기 상태입니다.

**연결 수립( accept() )**

API의 이름으로부터 알 수 있듯이 연결 요청을 받아들이는 역할을합니다. 연결 요청 정보는 시스템의 큐(Queue)에 쌓여있고, 이 큐로부터 꺼내와서 연결을 완료하게 됩니다.

그런데 주의할 점은 데이터 통신이 연결되는 소켓이 앞서 생성하고 바인딩한 소켓이 아닙니다. aceept API 내부에서 새로 만들어지는 소켓과 클라이언트 소켓이 연결되게 됩니다.

**데이터 송수신( send() / recv() )**

위의 내용과 동일합니다.

**소켓 종료 ( close() )**

소켓을 종료하는 것은 동일하지만, close()의 대상이 aceept() api로 생성한 소켓도 있다는 것을 인지해야 합니다.



#### 소켓과 HTTP 프로토콜의 차이점은?

HTTP는 응용 프로그램 프로토콜입니다. 이것은 기본적으로 HTTP 자체를 원격 엔드포인트로/로부터 정보를 전송하는 데 사용할 수 없다는 것을 의미합니다. 대신 HTTP의 경우 TCP인 기본 프로토콜에 의존한다.

반면에 소켓은 대부분의 운영 체제가 네트워크와 대화할 수 있도록 제공하는 API이다. 소켓 API는 전송 계층과 다운그레이드와는 다른 프로토콜을 지원합니다.

즉, TCP를 사용하려면 소켓을 사용해야 합니다. 그러나 소켓을 사용하여 HTTP를 사용하여 통신할 수도 있지만, 그런 다음 HTTP 사양(RFC2616)에 따라 메시지를 디코딩/엔코드해야 합니다. 이는 대부분의 개발자들에게 큰 작업이 될 수 있기 때문에, 우리는 또한 우리의 개발자 프레임워크에 준비된 클라이언트를 가지고 있었다.NET) 예를 들어 Web Client 또는 HttpWebRequest 클래스가 있습니다.

**HTTP 연결**

HTTP 연결은 소켓에서 실행되는 프로토콜입니다.
HTTP 연결은 네트워크 연결의 상위 단계 추상화입니다.
HTTP 연결을 통해 구현은 이러한 모든 상위 수준의 세부 정보를 처리하고 HTTP 요청(일부 헤더 정보)을 전송하고 서버로부터 HTTP 응답을 수신하기만 하면 됩니다.

**소켓 연결**

소켓은 시스템 간에 데이터를 전송하는 데 사용됩니다. 간단히 두 시스템을 연결하기만 하면 IP 주소는 IP 기반 네트워크를 통해 컴퓨터의 주소입니다.
소켓 연결을 사용하면 두 시스템 간의 네트워크 연결을 위한 프로토콜을 직접 설계할 수 있습니다.
소켓 연결을 사용하면 TCP/IP 연결의 하위 수준 세부 정보를 모두 처리해야 합니다.



https://recipes4dev.tistory.com/153

https://docs.oracle.com/javase/tutorial/networking/sockets/definition.html