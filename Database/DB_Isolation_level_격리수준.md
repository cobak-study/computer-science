# DB Isolation level

Date: Mar 23, 2021
Tags: Database, isolation level
공부함?: Yes

# Read Uncommitted

트랜잭션(T1)에서 커밋하지 않은 데이터가 다른 트랜잭션에서 읽을 수 있다.

발생 할 수 있는 문제: Dirty Read, Non-Repeatable, Phantom Read

**예)**

```sql
-- T1 트랜잭션에서의 INSERT
-- 현재 A테이블에는 c1 값이 각 [2, 3, 4]인 row가 3건 있다.
BEGIN
INSERT INTO A (c1) VALUES(1);
-- 아직 커밋 하지 않음
```

```sql
BEGIN
SELECT c1 FROM A WHERE c1 = 1;

-- 조회 됌
-- [1, 2, 3, 4]
```

# Read Committed

Dirty Read 부분은 해결되었지만, Non-Repeatable 이 해결되지 않은 격리수준 (`핵심, Undo 영역 사용하여 커밋 전에 상태를 보관`)

한번의 조회일 때는 Read의 정합성을 보장하지만 만약 여러번의 조회가 일어나는 도중 다른 트랜잭션에서 읽은 데이터에 대해 변경이나 삭제가 일어났을 때 Non-Repeatable이 일어날 수 있다.

SELECT를 할 때 실제테이블의 값으로 읽는 것이 아니라 undo 영역에 백업된 레코드를 읽어오기 때문에 다른 트랜잭션에서 변경하거나 삭제한다고 해도 Dirty Read 문제가 발생하지 않는다.

하지만 다른 트랜잭션에서 커밋을 완료하게 되면 undo 영역도 변경 되기 때문에 여러번의 똑같은 select 이더라도 다른 값을 읽을 수 있다. (이 문제를 Non-Repeatable 이라고 한다.)

1. (T1) 10번 사원의 나이를 조회
2. (T1) 27살이 조회됨 
3. (T1) 10번 사원의 나이를 27살에서 28살로 바꿈 (UNDO 영역에 27살 나이 데이터를 저장해둠)
4. (T2) 트랜잭션에서 10번 사원의 나이를 조회 
5. (T2) UNDO 영역에 있는 27살 나이로 조회
6. (T1) `커밋`
7. (T2) 한번 더 10번 사원의 나이를 조회
8. (T2) 28살 나이로 조회됌(?, 즉 Non-Repeatable 문제 발견)

# Repeatable READ

트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리수준

Dirty Read, Non-Repeatable가 해결된 격리수준

이 격리 레벨 수준에서는(MySQL), 트랜잭션마다 트랜잭션 ID를 부여하여 트랜잭션 ID보다 작은 트랜잭션번호에서 변경한 것만 읽는다. (READ COMMITTED 에서 발생하는 `Non-Repeatable` 문제 때문에, undo 영역을 읽되 본인보다 작은 트랜잭션 번호에서 변경한 것만 읽기 때문에, 여러번 SELECT를 하더라도 다른 트랜잭션(본인보다 더 큰 트랜잭션번호)에서 변경한 데이터로 읽지 않는다.

현재 나이가 20살인 사원의 ROW는 총 5건있음

1. (T2) 나이가 20살인 사원의 카운트를 조회 
2. (T2) 5건 조회
3. (T1) 나이가 20살인 사원의 카운트를 조회
4. (T1) 5건 조회
5. (T1) 나이가 20살인 사원 중 한 건의 로우를 20살에서 21살로 바꿈 (UNDO 영역에 20살 나이 데이터를 저장해둠)
6. (T1) `커밋`
7. (T2) 나이가 20살인 사원의 카운트를 조회 ( 본인보다 더 작은 트랜잭션 번호 ID를 가진 값만 읽기 때문에 T1의 변경사항은 읽지 않고 5건으로 조회됌)
8. (T2) `커밋`
9. (T1) 나이가 20살인 사원을 한 건 INSERT
10. (T2) 6건 조회 (?, 아직 T1이 커밋하지도 않은 사항에 대해 트랜잭션 번호가 더 높음에도 변경사항이 조회됌 ㅡ즉 `PHANTOM READ` 문제 발생)

# Serializable

모든 데이터 처리에 동기화를 걸어 모든 문제를 해결한다. (하지만 최근까지의 DBMS에서는 잘 사용하지 않는다. 동기화 문제 때문에 성능상 이슈가 있을 수 있음)

# 문제

### (1) Dirty Read

어떤 트랜잭션에서 변경하고 COMMIT 하지 않아도, 또 다른 트랜잭션에서 그 변경사항을 그대로 읽어들일 수 있다.

서로 다른 트랜잭션에서 작업이 완료(COMMIT)되지 않았는데도 데이터를 조회 할 수 있게 되는 현상

### (2) Non-Repeatable Read

한 트랜잭션(T1)이 데이타를 **Read** 하고 있다. 이때 다른 트랜잭션(T2)가 데이타에 접근하여 값을 변경 또는, 데이타를 삭제하고 커밋을 때려버리면?

그 후 T1이 다시 해당 데이타를 Read하고자 하면 변경된 데이타 혹은 사라진 데이타를 찾게 된다.

### (3) Phantom Read

트랜잭션(T1) 중에 특정 조건으로 데이타를 검색하여 결과를 얻었다. 이때 다른 트랜잭션(T2)가 접근해 해당 조건의 데이터 일부를 삭제 또는 추가 했을때, 아직 끝나지 않은 T1이 다시 한번 해당 조건으로 데이타를 조회 하면 T2에서 추가/삭제된 데이타가 함께 조회/누락 된다. 그리고 T2가 롤백을 하면? 데이터가 꼬인다

# 참고

> [https://feco.tistory.com/45](https://feco.tistory.com/45)
[https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation](https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation)